/*
 * Copyright (C) 2014 BlueKitchen GmbH
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 * 4. Any redistribution, use, or modification is done solely for
 *    personal benefit and not for any commercial purpose or for
 *    monetary gain.
 *
 * THIS SOFTWARE IS PROVIDED BY BLUEKITCHEN GMBH AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MATTHIAS
 * RINGWALD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Please inquire about commercial licensing options at 
 * contact@bluekitchen-gmbh.com
 *
 */

#define __BTSTACK_FILE__ "btstack_chipset_csr.c"

/*
 *  btstack_chipset_csr.c
 *
 *  Adapter to use CSR-based chipsets with BTstack
 *  SCO over HCI doesn't work over H4 connection and BTM805 module from Microchip Bluetooth Audio Developer Kit (CSR8811)
 */

/*
 * Copyright 2018 Sony Video & Sound Products Inc.
 *
 * Added some PSKEYs for CSR8811 on lc823450-xgevk
 *
 */

#include "btstack_chipset_csr.h"

#include <stddef.h>   /* NULL */
#include <stdio.h> 
#include <string.h>   /* memcpy */

#include "btstack_control.h"
#include "btstack_debug.h"
#include "btstack_util.h"
#include "hci_transport.h"

#ifdef OK
#undef OK
#endif

enum update_result {
    OK,
    SKIP,
};

// minimal CSR init script to configure PSKEYs and activate them. It uses store 0x0008 = psram.
static const uint8_t init_script[] = { 

    // 0x01fe: Set ANA_Freq to 26MHz
    0x00, 0xFC, 0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x01, 0x00, 0x03, 0x70, 0x00, 0x00, 0xfe, 0x01, 0x01, 0x00, 0x08, 0x00, 0x90, 0x65,

#ifdef CSR8811_PSKEYS
    // default tx power
    0x00, 0xfc, 0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x01, 0x00, 0x03, 0x70, 0x00, 0x00, 0x21, 0x00, 0x01, 0x00, 0x08, 0x00, 0x14, 0x00,

    // local supported features
    0x00, 0xfc, 0x19, 0xc2, 0x02, 0x00, 0x0c, 0x00, 0x05, 0x00, 0x03, 0x70, 0x00, 0x00, 0xef, 0x00, 0x04, 0x00, 0x08, 0x00, 0xff, 0xff, 0x8f, 0xfe, 0x9b, 0xff, 0x59, 0x87,

    // local supported commands
    0x00, 0xfc, 0x2f, 0xc2, 0x02, 0x00, 0x17, 0x00, 0x06, 0x00, 0x03, 0x70, 0x00, 0x00, 0x06, 0x01, 0x0f, 0x00, 0x08, 0x00, 0xff, 0xff, 0xff, 0x03, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0xe8, 0xfe, 0x3f, 0xf7, 0x83, 0xff, 0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
#endif

    // 0x00f2: Set HCI_NOP_DISABLE
    0x00, 0xFC, 0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x01, 0x00, 0x03, 0x70, 0x00, 0x00, 0xf2, 0x00, 0x01, 0x00, 0x08, 0x00, 0x01, 0x00,

#ifdef CSR8811_PSKEYS
    // MAX_SCOS=0 (000e)
    0x00, 0xfc, 0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x01, 0x00, 0x03, 0x70, 0x00, 0x00, 0x0e, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,

    // MAX_ACL_PKT_LEN
    0x00, 0xfc, 0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x02, 0x00, 0x03, 0x70, 0x00, 0x00, 0x11, 0x00, 0x01, 0x00, 0x08, 0x00, 0x53, 0x01,

    // MAX_ACK_PKTS
    0x00, 0xfc, 0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 0x70, 0x00, 0x00, 0x13, 0x00, 0x01, 0x00, 0x08, 0x00, 0x0b, 0x00,
#endif

#ifdef ENABLE_SCO_OVER_HCI
    // 0x01ab: Set HOSTIO_MAP_SCO_PCM to 0
    0x00, 0xFC, 0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x01, 0x00, 0x03, 0x70, 0x00, 0x00, 0xab, 0x01, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,
    // 0x01b0: Set HOSTIO_MAP_SCO_CODEC to 0
    0x00, 0xFC, 0x13, 0xc2, 0x00, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 0x70, 0x00, 0x00, 0xb0, 0x01, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,
    // 0x22c9: Set ENABLE_SCO_STREAMS to 0
    0x00, 0xFC, 0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x01, 0x00, 0x03, 0x70, 0x00, 0x00, 0xc9, 0x22, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,
#endif

    // 0x01bf: Enable RTS/CTS for BCSP (0806 -> 080e)
    0x00, 0xFC, 0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x01, 0x00, 0x03, 0x70, 0x00, 0x00, 0xbf, 0x01, 0x01, 0x00, 0x08, 0x00, 0x0e, 0x08,

    // 0x01ea: Set UART baudrate to 115200
    0x00, 0xFC, 0x15, 0xc2, 0x02, 0x00, 0x0a, 0x00, 0x02, 0x00, 0x03, 0x70, 0x00, 0x00, 0xea, 0x01, 0x02, 0x00, 0x08, 0x00, 0x01, 0x00, 0x00, 0xc2,

    // 0x0001: Set Bluetooth address 
    0x00, 0xFC, 0x19, 0xc2, 0x02, 0x00, 0x0A, 0x00, 0x03, 0x00, 0x03, 0x70, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x08, 0x00, 0xf3, 0x00, 0xf5, 0xf4, 0xf2, 0x00, 0xf2, 0xf1,

#ifdef CSR8811_PSKEYS
    // xtal evel
    0x00, 0xfc, 0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x11, 0x00, 0x03, 0x70, 0x00, 0x00, 0x41, 0x02, 0x01, 0x00, 0x08, 0x00, 0x09, 0x00,

    // patch50
    0x00, 0xfc, 0x31, 0xc2, 0x02, 0x00, 0x18, 0x00, 0x14, 0x00, 0x03, 0x70, 0x00, 0x00, 0x2c, 0x21, 0x10, 0x00, 0x08, 0x00, 0x00, 0x00, 0x7d, 0xc4, 0x14, 0x57, 0x18, 0x00, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0xd8, 0x18, 0x79, 0x9e, 0x00, 0x18, 0x00, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0xc5, 0x18, 0x80, 0xe2, 0x00, 0x80, 0x70,

    // patch51
    0x00, 0xfc, 0x43, 0xc2, 0x02, 0x00, 0x21, 0x00, 0x15, 0x00, 0x03, 0x70, 0x00, 0x00, 0x2d, 0x21, 0x19, 0x00, 0x08, 0x00, 0x02, 0x00, 0x79, 0x5b, 0x14, 0x00, 0x00, 0xe7, 0x25, 0x95, 0x1b, 0x01, 0x26, 0x06, 0x9a, 0x08, 0xf4, 0x0a, 0x18, 0x02, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0x5b, 0x18, 0x43, 0x9e, 0x00, 0x14, 0x00, 0x1b, 0x01, 0x26, 0x08, 0x18, 0x02, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0x5c, 0x18, 0x82, 0xe2, 0x00, 0x3a, 0xa6,

    // patch52
    0x00, 0xfc, 0x5d, 0xc2, 0x02, 0x00, 0x2e, 0x00, 0x16, 0x00, 0x03, 0x70, 0x00, 0x00, 0x2e, 0x21, 0x26, 0x00, 0x08, 0x00, 0x02, 0x00, 0xa7, 0xd0, 0x16, 0x03, 0x18, 0x03, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0x23, 0x18, 0x06, 0x9e, 0x00, 0x99, 0xe1, 0xf4, 0x14, 0x19, 0xe1, 0x12, 0x08, 0x00, 0x80, 0xc0, 0x00, 0xf0, 0x10, 0x1b, 0x06, 0x12, 0x02, 0x00, 0x01, 0xc0, 0xff, 0x80, 0x07, 0xf0, 0x0a, 0x16, 0x03, 0x10, 0x00, 0x18, 0x03, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0x38, 0x18, 0x13, 0x9e, 0x00, 0x0f, 0xf7, 0x18, 0x02, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0xd1, 0x18, 0xac, 0xe2, 0x00, 0x53, 0xcf,

    // patch53
    0x00, 0xfc, 0x45, 0xc2, 0x02, 0x00, 0x22, 0x00, 0x17, 0x00, 0x03, 0x70, 0x00, 0x00, 0x2f, 0x21, 0x1a, 0x00, 0x08, 0x00, 0x03, 0x00, 0x16, 0xc9, 0x14, 0x01, 0x27, 0x00, 0x17, 0x05, 0x00, 0x2b, 0x84, 0xa4, 0xf0, 0x06, 0x00, 0x2b, 0x14, 0xa9, 0x27, 0x05, 0x14, 0x01, 0xe0, 0x02, 0x14, 0x00, 0x27, 0x01, 0x14, 0x00, 0x27, 0x02, 0x23, 0x03, 0x15, 0xe3, 0x18, 0x03, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0xc9, 0x18, 0x1d, 0xe2, 0x00, 0x5f, 0xcb,

    // patch54 (2130)
    0x00, 0xfc, 0x41, 0xc2, 0x02, 0x00, 0x20, 0x00, 0x18, 0x00, 0x03, 0x70, 0x00, 0x00, 0x30, 0x21, 0x18, 0x00, 0x08, 0x00, 0x02, 0x00, 0x7a, 0xca, 0x18, 0x00, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0x84, 0x18, 0xcb, 0x9e, 0x00, 0x00, 0xea, 0x11, 0x5f, 0x00, 0x01, 0x80, 0x00, 0x24, 0x05, 0x00, 0x01, 0xb0, 0x00, 0x00, 0xea, 0x21, 0x5f, 0x18, 0x02, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0xca, 0x18, 0x7d, 0xe2, 0x00, 0x13, 0x25,

    // patch63 (2139)
    0x00, 0xfc, 0x47, 0xc2, 0x02, 0x00, 0x23, 0x00, 0x19, 0x00, 0x03, 0x70, 0x00, 0x00, 0x39, 0x21, 0x1b, 0x00, 0x08, 0x00, 0x01, 0x00, 0x02, 0x8d, 0x18, 0x00, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0xd6, 0x18, 0xcc, 0x9e, 0x00, 0x18, 0x01, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0x79, 0x18, 0x31, 0x9e, 0x00, 0x99, 0xe1, 0xf4, 0x09, 0x00, 0xe1, 0x19, 0xb2, 0x16, 0x03, 0x27, 0xfe, 0x16, 0x02, 0x27, 0xff, 0x0e, 0xff, 0x9f, 0xfe, 0x14, 0x01, 0x0f, 0xf8, 0x6f, 0xd0,

    // patch64 (213a)
    0x00, 0xfc, 0x5b, 0xc2, 0x02, 0x00, 0x2d, 0x00, 0x1a, 0x00, 0x03, 0x70, 0x00, 0x00, 0x3a, 0x21, 0x25, 0x00, 0x08, 0x00, 0x00, 0x00, 0xae, 0xd5, 0x18, 0x01, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0x6a, 0x18, 0xe4, 0x9e, 0x00, 0x99, 0xe1, 0xf4, 0x15, 0x13, 0x05, 0x00, 0x77, 0x80, 0xb5, 0xf4, 0x02, 0x34, 0x05, 0x19, 0xe1, 0x16, 0x00, 0x34, 0x04, 0x25, 0xf8, 0x16, 0x01, 0xa0, 0x08, 0x35, 0xf8, 0x1b, 0x02, 0x26, 0x01, 0x18, 0x00, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0xd6, 0x18, 0xbf, 0xe2, 0x00, 0x18, 0x00, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0xd6, 0x18, 0xbc, 0xe2, 0x00, 0x2a, 0xc3,

    // patch65 (213b)
    0x00, 0xfc, 0x4f, 0xc2, 0x02, 0x00, 0x27, 0x00, 0x1b, 0x00, 0x03, 0x70, 0x00, 0x00, 0x3b, 0x21, 0x1f, 0x00, 0x08, 0x00, 0x01, 0x00, 0xae, 0x8c, 0xf0, 0x0a, 0x00, 0xe1, 0x15, 0xa3, 0x18, 0x01, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0x69, 0x18, 0xa5, 0x9e, 0x00, 0x0f, 0xf8, 0x9b, 0x04, 0xf0, 0x0b, 0x00, 0xe1, 0x14, 0xa1, 0x00, 0xe5, 0x10, 0xed, 0x18, 0x00, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0xd6, 0x18, 0x8c, 0x9e, 0x00, 0x18, 0x01, 0x2b, 0xff, 0x0e, 0xff, 0x00, 0x8d, 0x18, 0xcc, 0xe2, 0x00, 0xa7, 0xdf,

    // bt_mixer_ctrim_max (216d)
    0x00, 0xfc, 0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x1c, 0x00, 0x03, 0x70, 0x00, 0x00, 0x6d, 0x21, 0x01, 0x00, 0x08, 0x00, 0x07, 0x00,

    // bt_tx_mixer_ctrim_offset (2175)
    0x00, 0xfc, 0x1b, 0xc2, 0x02, 0x00, 0x0d, 0x00, 0x1d, 0x00, 0x03, 0x70, 0x00, 0x00, 0x75, 0x21, 0x05, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xee, 0xee, 0xee, 0xee,

    // patch 112 (2200)
    0x00, 0xfc, 0x1f, 0xc2, 0x02, 0x00, 0x0f, 0x00, 0x1e, 0x00, 0x03, 0x70, 0x00, 0x00, 0x00, 0x22, 0x07, 0x00, 0x08, 0x00, 0x00, 0xf1, 0x15, 0xcf, 0xb4, 0x01, 0x00, 0xf1, 0x25, 0xcf, 0xe2, 0x00, 0xd1, 0x9d,

    // BT power table V0
    0x00, 0xfc, 0x57, 0xc2, 0x02, 0x00, 0x2b, 0x00, 0x1f, 0x00, 0x03, 0x70, 0x00, 0x00, 0x1a, 0x24, 0x23, 0x00, 0x08, 0x00, 0x05, 0x27, 0x50, 0x00, 0x05, 0x2c, 0x50, 0x00, 0x00, 0xef, 0x05, 0x29, 0x40, 0x00, 0x05, 0x2e, 0x40, 0x00, 0x00, 0xf3, 0x05, 0x28, 0x30, 0x00, 0x05, 0x2c, 0x30, 0x00, 0x00, 0xf7, 0x05, 0x28, 0x20, 0x00, 0x05, 0x2c, 0x20, 0x00, 0x00, 0xfb, 0x05, 0x29, 0x10, 0x00, 0x05, 0x2d, 0x10, 0x00, 0x00, 0xff, 0x0a, 0x2d, 0x00, 0x00, 0x0a, 0x30, 0x00, 0x00, 0x00, 0x03, 0xba, 0x27, 0x00, 0x00, 0xcc, 0x28, 0x00, 0x00, 0x00, 0x07,
#endif

    //  WarmReset
    0x00, 0xFC, 0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x03, 0x0e, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
};
static const uint16_t init_script_size = sizeof(init_script);

//
static uint32_t init_script_offset  = 0;
static hci_transport_config_uart_t * hci_transport_config_uart = NULL;
static int       set_bd_addr;
static bd_addr_t bd_addr;

static void chipset_init(const void * config){
    init_script_offset = 0;
    hci_transport_config_uart = NULL;
    // check for hci_transport_config_uart_t
    if (!config) return;
    if (((hci_transport_config_t*)config)->type != HCI_TRANSPORT_CONFIG_UART) return;
    hci_transport_config_uart = (hci_transport_config_uart_t*) config;
}

// set requested baud rate
// @return 0 = OK, 1 = SKIP, 2 = ..
static enum update_result update_init_script_command(uint8_t *hci_cmd_buffer){
    uint16_t varid = little_endian_read_16(hci_cmd_buffer, 10);
    if (varid != 0x7003) return OK;
    uint16_t key = little_endian_read_16(hci_cmd_buffer, 14);
    log_info("csr: pskey 0x%04x", key);
    switch (key){
        case 0x001:
            // set bd addr command
            if (!set_bd_addr) return SKIP;
            hci_cmd_buffer[20] = bd_addr[3];
            hci_cmd_buffer[22] = bd_addr[5];
            hci_cmd_buffer[23] = bd_addr[4];
            hci_cmd_buffer[24] = bd_addr[2];
            hci_cmd_buffer[26] = bd_addr[1];
            hci_cmd_buffer[27] = bd_addr[0];
            return OK;
        case 0x01ea:
            // baud rate command
            if (!hci_transport_config_uart) return OK;
            uint32_t baudrate = hci_transport_config_uart->baudrate_main;
            if (baudrate == 0){
                baudrate = hci_transport_config_uart->baudrate_init;
            }
            // uint32_t is stored as 2 x uint16_t with most important 16 bits first
            little_endian_store_16(hci_cmd_buffer, 20, baudrate >> 16);
            little_endian_store_16(hci_cmd_buffer, 22, baudrate &  0xffff);
            break;
        default:
            break;        
    }
    return OK;
}

static btstack_chipset_result_t chipset_next_command(uint8_t * hci_cmd_buffer){

    while (1){

        if (init_script_offset >= init_script_size) {
            return BTSTACK_CHIPSET_DONE;
        }

        // copy command header
        memcpy(&hci_cmd_buffer[0], (uint8_t *) &init_script[init_script_offset], 3); 
        init_script_offset += 3;
        int payload_len = hci_cmd_buffer[2];
        // copy command payload
        memcpy(&hci_cmd_buffer[3], (uint8_t *) &init_script[init_script_offset], payload_len);

        // support for on-the-fly configuration updates
        enum update_result res = update_init_script_command(hci_cmd_buffer);
        init_script_offset += payload_len;

        // support for skipping commands
        if (res == SKIP) continue;

        // support for warm boot command
        uint16_t varid = little_endian_read_16(hci_cmd_buffer, 10);
        if (varid == 0x4002){
            return BTSTACK_CHIPSET_WARMSTART_REQUIRED;
        }

        return BTSTACK_CHIPSET_VALID_COMMAND;         
    }
}


static const btstack_chipset_t btstack_chipset_bcm = {
    "CSR",
    chipset_init,
    chipset_next_command,
    NULL, // chipset_set_baudrate_command,
    NULL, // chipset_set_bd_addr_command not supported or implemented
};

// MARK: public API
const btstack_chipset_t * btstack_chipset_csr_instance(void){
    return &btstack_chipset_bcm;
}

/** 
 * Set BD ADDR before HCI POWER_ON
 * @param bd_addr
 */
void btstack_chipset_csr_set_bd_addr(bd_addr_t new_bd_addr){
    set_bd_addr = 1;
    memcpy(bd_addr, new_bd_addr, 6);
}
